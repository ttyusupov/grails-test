package org.tyusupov

/**
 * @author Timur
 * @date 2016-10-22.
 */
class TestService {
    Parent getOrCreateParent(String parentName) {
        Parent p = Parent.findByName(parentName)
        if (p == null) {
            p = new Parent(name: parentName)
            p.save(failOnError: true)
        }
        return p
    }

    Child addChildWithParentUpdate(String parentName, String childName) {
        Parent.withNewSession {
            Parent.withNewTransaction {
                Parent p = Parent.findByName(parentName)
                Child c = new Child(name: childName, parent: p, counter: 0)
                // if we first associate with parent and the save - GORM will update parent
                p.addToChilds(c)
                c.save(failOnError: true)
                return c
            }
        }
    }

    Child addChildWithoutParentUpdate(String parentName, String childName) {
        Parent.withNewSession {
            Parent.withNewTransaction {
                Parent p = Parent.findByName(parentName)
                Child c = new Child(name: childName, parent: p, counter: 0)
                // if we first save and then associate with parent - GORM will not update parent
                c.save(failOnError: true)
                p.addToChilds(c)
                return c
            }
        }
    }

    Child addChildWithParentUpdateLock(String parentName, String childName) {
        Parent.withNewSession {
            Parent.withNewTransaction {
                Parent p = Parent.findByName(parentName)
                // lock parent to avoid deadlock due to order of SQL statement generated by GORM (insert into child; update parent)
                p.lock()
                Child c = new Child(name: childName, parent: p, counter: 0)
                p.addToChilds(c)
                c.save(failOnError: true)
                return c
            }
        }
    }

    void testSameParentWithUpdate() {
        // this scenario produces MySql deadlock
        getOrCreateParent("P")
        Thread.start {
            addChildWithParentUpdate("P", "1")
        }
        Thread.start {
            addChildWithParentUpdate("P", "2")
        }
    }

    void testDifferentParentsWithUpdate() {
        // this scenario works fine
        getOrCreateParent("P1")
        getOrCreateParent("P2")
        Thread.start {
            addChildWithParentUpdate("P1", "1")
        }
        Thread.start {
            addChildWithParentUpdate("P2", "2")
        }
    }

    void testSameParentWithoutUpdate() {
        // this scenario works fine (parent is not updated)
        getOrCreateParent("P")
        Thread.start {
            addChildWithoutParentUpdate("P", "1")
        }
        Thread.start {
            addChildWithoutParentUpdate("P", "2")
        }
    }

    void testSameParentWithUpdateLock() {
        // in this scenario there is no deadlock, but we get StaleObjectStateException: Row was updated or deleted by another transaction
        getOrCreateParent("P")
        Thread.start {
            addChildWithParentUpdateLock("P", "1")
        }
        Thread.start {
            addChildWithParentUpdateLock("P", "2")
        }
    }

    void ensureTestComponentAndTicketsCreated() {
        Component.withNewSession {
            Component.findOrSaveByName("A", [failOnError: true])
            Component.findOrSaveByName("B", [failOnError: true])
            Ticket.findOrSaveByTitle("T1", [failOnError: true])
            Ticket.findOrSaveByTitle("T2", [failOnError: true])
        }
    }

    void dumpTestComponentsAndTicketsVersions() {
        Component.withNewSession {
            Component a = Component.findByName("A")
            Component b = Component.findByName("B")
            Ticket t1 = Ticket.findByTitle("T1")
            log.info("${a} version: ${a.version}")
            log.info("${b} version: ${b.version}")
            log.info("${t1} version: ${t1.version}")
        }
    }

    void testM2m() {
        ensureTestComponentAndTicketsCreated()
        dumpTestComponentsAndTicketsVersions()
        Component.withNewSession {
            Component.withNewTransaction {
                Component a = Component.findByName("A")
                Ticket t1 = Ticket.findByTitle("T1")
                t1.addToComponents(a).save(failOnError: true, flush: true)
                println "${t1.components}"
            }
        }
        dumpTestComponentsAndTicketsVersions()
    }
}
