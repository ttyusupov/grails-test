package org.tyusupov

/**
 * @author Timur
 * @date 2016-10-22.
 */
class TestService {
    Parent getOrCreateParent(String parentName) {
        Parent p = Parent.findByName(parentName)
        if (p == null) {
            p = new Parent(name: parentName)
            p.save(failOnError: true)
        }
        return p
    }

    Child addChildWithParentUpdate(String parentName, String childName) {
        Parent.withNewSession {
            Parent.withNewTransaction {
                Parent p = Parent.findByName(parentName)
                Child c = new Child(name: childName, parent: p, counter: 0)
                // if we first associate with parent and the save - GORM will update parent
                p.addToChilds(c)
                c.save(failOnError: true)
                return c
            }
        }
    }

    Child addChildWithoutParentUpdate(String parentName, String childName) {
        Parent.withNewSession {
            Parent.withNewTransaction {
                Parent p = Parent.findByName(parentName)
                Child c = new Child(name: childName, parent: p, counter: 0)
                // if we first save and then associate with parent - GORM will not update parent
                c.save(failOnError: true)
                p.addToChilds(c)
                return c
            }
        }
    }

    Child addChildWithParentUpdateLock(String parentName, String childName) {
        Parent.withNewSession {
            Parent.withNewTransaction {
                Parent p = Parent.findByName(parentName)
                // lock parent to avoid deadlock due to order of SQL statement generated by GORM (insert into child; update parent)
                p.lock()
                Child c = new Child(name: childName, parent: p, counter: 0)
                p.addToChilds(c)
                c.save(failOnError: true)
                return c
            }
        }
    }

    void testSameParentWithUpdate() {
        // this scenario produces MySql deadlock
        getOrCreateParent("P")
        Thread.start {
            addChildWithParentUpdate("P", "1")
        }
        Thread.start {
            addChildWithParentUpdate("P", "2")
        }
    }

    void testDifferentParentsWithUpdate() {
        // this scenario works fine
        getOrCreateParent("P1")
        getOrCreateParent("P2")
        Thread.start {
            addChildWithParentUpdate("P1", "1")
        }
        Thread.start {
            addChildWithParentUpdate("P2", "2")
        }
    }

    void testSameParentWithoutUpdate() {
        // this scenario works fine (parent is not updated)
        getOrCreateParent("P")
        Thread.start {
            addChildWithoutParentUpdate("P", "1")
        }
        Thread.start {
            addChildWithoutParentUpdate("P", "2")
        }
    }

    void testSameParentWithUpdateLock() {
        // in this scenario there is no deadlock, but we get StaleObjectStateException: Row was updated or deleted by another transaction
        getOrCreateParent("P")
        Thread.start {
            addChildWithParentUpdateLock("P", "1")
        }
        Thread.start {
            addChildWithParentUpdateLock("P", "2")
        }
    }
}
